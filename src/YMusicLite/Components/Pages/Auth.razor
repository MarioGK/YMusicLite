@page "/auth"
@inject IGoogleAuthService GoogleAuthService
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation

<PageTitle>Authentication - YMusicLite</PageTitle>

<MudContainer MaxWidth="MaxWidth.Small" Class="mt-16">
    <MudPaper Class="pa-8">
        <MudText Typo="Typo.h4" Align="Align.Center" GutterBottom="true">YouTube Authentication</MudText>
        
        <MudText Typo="Typo.body1" Class="mb-6">
            To access your private playlists and enable automatic syncing, you need to authenticate with your Google/YouTube account.
        </MudText>
        
        @if (IsLoading)
        {
            <div class="d-flex justify-center mb-4">
                <MudProgressCircular Indeterminate="true" />
            </div>
            <MudText Typo="Typo.body2" Align="Align.Center">Processing authentication...</MudText>
        }
        else if (HasError)
        {
            <MudAlert Severity="Severity.Error" Class="mb-4">
                @ErrorMessage
            </MudAlert>
        }
        else if (IsAuthenticated)
        {
            <MudAlert Severity="Severity.Success" Class="mb-4">
                Successfully authenticated as @UserDisplayName
            </MudAlert>
            @if (Accounts.Any())
            {
                <MudText Typo="Typo.subtitle2" Class="mb-2">Accounts</MudText>
                <MudList T="string" Dense="true" Class="mb-4">
                    @foreach (var acc in Accounts)
                    {
                        <MudListItem T="string" OnClick="@(() => SelectAccount(acc.GoogleId))">
                            @(acc.DisplayName) <MudChip Class="ml-2" Color="@(acc.GoogleId==CurrentUserId?Color.Success:Color.Default)" Size="Size.Small">@(acc.GoogleId==CurrentUserId?"Active":"Switch")</MudChip>
                        </MudListItem>
                    }
                </MudList>
            }
            @if (PrivatePlaylists.Any())
            {
                <MudText Typo="Typo.h6" Class="mb-2">Your Private Playlists (first @PrivatePlaylists.Count)</MudText>
                <MudList T="string" Dense="true" Class="mb-4">
                    @foreach (var p in PrivatePlaylists)
                    {
                        <MudListItem T="string">@p.Snippet.Title (@p.ContentDetails?.ItemCount ?? 0)</MudListItem>
                    }
                </MudList>
            }
            else
            {
                <MudText Typo="Typo.body2" Class="mb-4">No playlists retrieved yet.</MudText>
            }
            <div class="d-flex justify-center mb-2">
                <MudButton Variant="Variant.Filled" 
                          Color="Color.Primary" 
                          OnClick="NavigateToPlaylists">
                    Go to Playlists
                </MudButton>
            </div>
            <div class="d-flex justify-center">
                <MudButton Variant="Variant.Outlined" Color="Color.Secondary" StartIcon="@Icons.Material.Filled.Add" OnClick="StartAuthentication">Add Another Account</MudButton>
            </div>
        }
        else
        {
            <div class="d-flex justify-center mb-4">
                <MudButton Variant="Variant.Filled" 
                          Color="Color.Primary" 
                          Size="Size.Large"
                          StartIcon="@Icons.Custom.Brands.Google"
                          OnClick="StartAuthentication">
                    Sign in with Google
                </MudButton>
            </div>
            
            <MudText Typo="Typo.caption" Align="Align.Center">
                We only request read-only access to your YouTube playlists
            </MudText>
        }
    </MudPaper>
</MudContainer>

@code {
    private bool IsLoading = false;
    private bool HasError = false;
    private bool IsAuthenticated = false;
    private string ErrorMessage = string.Empty;
    private string UserDisplayName = string.Empty;
    private List<Google.Apis.YouTube.v3.Data.Playlist> PrivatePlaylists = new();
    private List<User> Accounts = new();
    private string? CurrentUserId;

    [Parameter, SupplyParameterFromQuery]
    public string? Code { get; set; }

    [Parameter, SupplyParameterFromQuery] 
    public string? State { get; set; }

    [Parameter, SupplyParameterFromQuery]
    public string? Error { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // Check if this is a callback from Google OAuth
        if (!string.IsNullOrEmpty(Code) && !string.IsNullOrEmpty(State))
        {
            await HandleOAuthCallback();
        }
        else if (!string.IsNullOrEmpty(Error))
        {
            HasError = true;
            ErrorMessage = $"Authentication failed: {Error}";
        }
        else
        {
            await LoadAccounts();
        }
    }

    private async Task StartAuthentication()
    {
        try
        {
            IsLoading = true;
            StateHasChanged();

            // Generate a random user ID for this session (in real app, you'd use actual user management)
            var userId = Guid.NewGuid().ToString();
            var redirectUri = $"{Navigation.BaseUri}auth";
            
            var authUrl = await GoogleAuthService.GetAuthorizationUrlAsync(userId, redirectUri);
            
            // Store userId in local storage or session for callback
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "tempUserId", userId);
            
            // Redirect to Google OAuth
            Navigation.NavigateTo(authUrl, forceLoad: true);
        }
        catch (Exception ex)
        {
            HasError = true;
            ErrorMessage = $"Failed to start authentication: {ex.Message}";
            IsLoading = false;
            StateHasChanged();
        }
    }

    private async Task HandleOAuthCallback()
    {
        try
        {
            IsLoading = true;
            StateHasChanged();

            // Determine authoritative userId:
            // 1. Prefer State query parameter (passed back from OAuth as 'state')
            // 2. Fallback to previously stored tempUserId in localStorage
            // 3. If still missing, abort (cannot correlate PKCE verifier)
            string? userId = State;
            if (string.IsNullOrWhiteSpace(userId))
            {
                userId = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "tempUserId");
            }
            if (string.IsNullOrWhiteSpace(userId))
            {
                throw new InvalidOperationException("No user session found");
            }
            // Persist (overwrite) authoritative userId back to localStorage to ensure consistency
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "tempUserId", userId);

            var redirectUri = $"{Navigation.BaseUri}auth";
            var user = await GoogleAuthService.AuthorizeAsync(userId, Code!, redirectUri);
            
            if (user != null)
            {
                IsAuthenticated = true;
                UserDisplayName = user.DisplayName;
                CurrentUserId = user.GoogleId;
                // Fetch initial set of private playlists
                var lists = await GoogleAuthService.GetPrivatePlaylistsAsync(user.GoogleId, 25);
                PrivatePlaylists = lists.ToList();
                
                // Clear temporary storage
                await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "tempUserId");
                
                // Store authenticated user info for the session
                await JSRuntime.InvokeVoidAsync("localStorage.setItem", "currentUserId", user.GoogleId);
                await LoadAccounts();
            }
            else
            {
                throw new InvalidOperationException("Authentication failed - unable to get user information");
            }
        }
        catch (Exception ex)
        {
            HasError = true;
            ErrorMessage = $"Authentication failed: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    private void NavigateToPlaylists()
    {
        Navigation.NavigateTo("/playlists");
    }

    private async Task LoadAccounts()
    {
        try
        {
            var list = await GoogleAuthService.ListAuthenticatedUsersAsync();
            Accounts = list.ToList();
            CurrentUserId ??= await JSRuntime.InvokeAsync<string>("localStorage.getItem", "currentUserId");
            if (!string.IsNullOrEmpty(CurrentUserId) && Accounts.All(a => a.GoogleId != CurrentUserId))
            {
                CurrentUserId = Accounts.FirstOrDefault()?.GoogleId;
            }
            if (!string.IsNullOrEmpty(CurrentUserId))
            {
                IsAuthenticated = true;
                var active = Accounts.FirstOrDefault(a => a.GoogleId == CurrentUserId);
                if (active != null)
                {
                    UserDisplayName = active.DisplayName;
                    var lists = await GoogleAuthService.GetPrivatePlaylistsAsync(CurrentUserId, 25);
                    PrivatePlaylists = lists.ToList();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load accounts: {ex.Message}");
        }
        StateHasChanged();
    }

    private async Task SelectAccount(string googleId)
    {
        CurrentUserId = googleId;
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", "currentUserId", googleId);
        var lists = await GoogleAuthService.GetPrivatePlaylistsAsync(googleId, 25);
        PrivatePlaylists = lists.ToList();
        var acc = Accounts.FirstOrDefault(a => a.GoogleId == googleId);
        if (acc != null)
        {
            UserDisplayName = acc.DisplayName;
        }
        IsAuthenticated = true;
        StateHasChanged();
    }
}